# ch2. 아키텍처 개요

### 2.1 네 개의 영역
- 표현, 응용, 도메인, 인프라스트럭처는 아키텍처를 설계할 때 출현하는 전형적인 네 가지 영역이다.
- 표현(UI) 영역은 사용자의 요청을 받아 응용 영역에 전달하고 응용 영역의 처리 결과를 다시 사용자에게 보여주는 역할을 한다. 
- 스프링 MVC 프레임워크가 표현 영역을 위한 기술에 해당 한다.
<img src="https://heeveloper.github.io/img/DDDStart/2-architecture.png" width=400px>

- 응용 서비스는 로직을 직접 수행하기보다는 도메인 모델에 로직 수행을 위임한다.
<img src="https://velog.velcdn.com/images/gehwan96/post/cccba6b2-42d9-4dfd-a648-3d8986429870/image.png" width=400px>

- 도메인 영역은 도메인 모델을 구현한다. 
- 도메인 모델은 도메인의 핵심 로직을 구현한다.

- 인프라스트럭처 영역은 구현 기술에 대한 것을 다룬다.
- 즉, RDBMS 연동, 데이터 연동, 메시징 큐에 메시지를 전송하거나 수신하는 기능을 구현한다.
- 인프라스트럭처 영역은 논리적인 개념을 표현하기보다는 실제 구현을 다룬다.
<img src="https://velog.velcdn.com/images/gehwan96/post/b5f736a8-a4de-4ef2-9df1-384f136fbaba/image.png" width=400px>

- **도메인 영역, 응용 영역, 표현 영역은 구현 기술을 사용한 코드를 직접 만들지 않는다.**
- **대신 인프라스트럭처 영역에서 제공하는 기능을 사용해서 필요한 기능을 개발한다.**

### 2.2 계층 구조 아키텍처
<img src="https://songii00.github.io/2020/07/13/DDDStart!_Item_2/2.png" width=400px>

- 표현 영역과 응용 영역은 도메인 영역을 사용하고, 도메인 영역은 인프라스트럭처 영역을 사용하므로 계층 구조를 적용하기 적당해 보인다.
- 계층 구조는 그 특성상 상위 계층에서 하위 계층으로의 의존만 존재하고, 하위 계층은 상위 계층에 의존하지 않는다.
- 구현의 편리함을 위해 계층 구조를 유연하게 적용하기도 한다. ex) 응용 계층의 인프라스트럭처 계층 의존

<img src="https://velog.velcdn.com/images/gehwan96/post/d561ee29-b9e1-437d-a3db-bb6f7fe599af/image.png" width=400px>

- 상위 계층의 상세한 구현 기술은 인프라스트럭처 계층에 종속된다. 
> **하지만 인프라스트럭처에 의존하면 "테스트 어려움"과 "기능 확장의 어려움"이라는 두 가지 문제가 발생한다.**
- 해답은 DIP에 있다

### 2.3 DIP(Dependency Inversion Principle) : 의존 역전 원칙
- 저수준 모듈이 고수준 모듈에 의존하도록 하는 것. 

<img src="https://kjgleh.github.io/asset/images/ddd/ddd_start_02_01.PNG" width=400px>

- 고수준 모듈과 저수준 모듈
    - 고수준 모듈은 의미 있는 단일 기능을 제공하는 모듈
    - 저수준 모듈은 하위 기능을 실제로 구현한 모듈
- 고수준 모듈이 제대로 동작하려면 저수준 모듈을 사용해야 한다. 그러나 이렇게 되면 구현 변경과 테스트가 어렵다는 문제가 발생한다.

- DIP는 이 문제를 해결하기 위해 저수준 모듈이 고수준 모듈에 의존하도록 바꾼다.
- 저수준 모듈이 고수준 모듈에 의존하도록 하려면, **추상화된 인터페이스**를 사용하는 것으로 해결할 수 있다.

- 저수준 모듈을 인터페이스화해서 이를 상속받아 구현한다.
- 고수준 모듈은 이 인터페이스에만 의존한다. 이 인터페이스는 고수준 모듈에 속한다.
```java
/// 사용할 저수준 객체, 앞은 인터페이스, 뒤는 상속받아 구현한 객체
RuleDiscounter ruleDiscounter = new DroolsRuleDiscounter();

// 생성자 방식으로 주입
CalculateDiscounterService disService = new CalculateDiscounterService(ruleDiscounter);
```
- 구현 기술을 변경하더라도 Service를 변경하는 것이 아니라, 저수준 구현 객체를 생성하는 코드만 변경하면 된다.(즉, 인터페이스를 상속받는 또 다른 저수준 모듈을 생성)

#### 2.3.1 DIP 주의 사항
<img src="https://nesoy.github.io/assets/posts/20180812/4.png" width=400px>
- 그림의 박스처럼 도메인에 인터페이스, Service가 위치하고, 인프라에 인터페이스를 구현한 저수준 모듈이 위치해야 한다.
- DIP는 단순히 인터페이스와 구현 클래스를 분리하는 것이 아니다.
- 저수준 모듈에서 인터페이스를 도출하는 것이 아니라, 고수준 모듈 관점에서 인터페이스를 도출해야 한다.

#### 2.3.2 DIP와 아키텍처
<img src="https://heeveloper.github.io/img/DDDStart/2-dip-architecture.png" width=400px>

- 인프라스트럭처 영역이 응용 영역과 도메인 영역에 의존(상속)하는 구조가 된다.
- DIP를 적용하면 응용 영역과 도메인 영역에 영향을 최소화하면서 구현체를 변경하거나 추가할 수 있다.
> DIP를 항상 적용할 필요는 없다. 포함하는 게 효과적일 때도 있다. 무작정 적용하는 것이 아니라 DIP의 이점을 얻는 수준에서 적용을 검토하자.

### 2.4 도메인 영역의 주요 구성요소
