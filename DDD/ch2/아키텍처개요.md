# ch2. 아키텍처 개요

### 2.1 네 개의 영역
- 표현, 응용, 도메인, 인프라스트럭처는 아키텍처를 설계할 때 출현하는 전형적인 네 가지 영역이다.
- 표현(UI) 영역은 사용자의 요청을 받아 응용 영역에 전달하고 응용 영역의 처리 결과를 다시 사용자에게 보여주는 역할을 한다. 
- 스프링 MVC 프레임워크가 표현 영역을 위한 기술에 해당 한다.
<img src="https://heeveloper.github.io/img/DDDStart/2-architecture.png" width=400px>

- 응용 서비스는 로직을 직접 수행하기보다는 도메인 모델에 로직 수행을 위임한다.
<img src="https://velog.velcdn.com/images/gehwan96/post/cccba6b2-42d9-4dfd-a648-3d8986429870/image.png" width=400px>

- 도메인 영역은 도메인 모델을 구현한다. 
- 도메인 모델은 도메인의 핵심 로직을 구현한다.

- 인프라스트럭처 영역은 구현 기술에 대한 것을 다룬다.
- 즉, RDBMS 연동, 데이터 연동, 메시징 큐에 메시지를 전송하거나 수신하는 기능을 구현한다.
- 인프라스트럭처 영역은 논리적인 개념을 표현하기보다는 실제 구현을 다룬다.
<img src="https://velog.velcdn.com/images/gehwan96/post/b5f736a8-a4de-4ef2-9df1-384f136fbaba/image.png" width=400px>

- **도메인 영역, 응용 영역, 표현 영역은 구현 기술을 사용한 코드를 직접 만들지 않는다.**
- **대신 인프라스트럭처 영역에서 제공하는 기능을 사용해서 필요한 기능을 개발한다.**

### 2.2 계층 구조 아키텍처
<img src="https://songii00.github.io/2020/07/13/DDDStart!_Item_2/2.png" width=400px>

- 표현 영역과 응용 영역은 도메인 영역을 사용하고, 도메인 영역은 인프라스트럭처 영역을 사용하므로 계층 구조를 적용하기 적당해 보인다.
- 계층 구조는 그 특성상 상위 계층에서 하위 계층으로의 의존만 존재하고, 하위 계층은 상위 계층에 의존하지 않는다.
- 구현의 편리함을 위해 계층 구조를 유연하게 적용하기도 한다. ex) 응용 계층의 인프라스트럭처 계층 의존

<img src="https://velog.velcdn.com/images/gehwan96/post/d561ee29-b9e1-437d-a3db-bb6f7fe599af/image.png" width=400px>

- 상위 계층의 상세한 구현 기술은 인프라스트럭처 계층에 종속된다. 
> **하지만 인프라스트럭처에 의존하면 "테스트 어려움"과 "기능 확장의 어려움"이라는 두 가지 문제가 발생한다.**
- 해답은 DIP에 있다

### 2.3 DIP(Dependency Inversion Principle) : 의존 역전 원칙
- 저수준 모듈이 고수준 모듈에 의존하도록 하는 것. 

<img src="https://kjgleh.github.io/asset/images/ddd/ddd_start_02_01.PNG" width=400px>

- 고수준 모듈과 저수준 모듈
    - 고수준 모듈은 의미 있는 단일 기능을 제공하는 모듈
    - 저수준 모듈은 하위 기능을 실제로 구현한 모듈
- 고수준 모듈이 제대로 동작하려면 저수준 모듈을 사용해야 한다. 그러나 이렇게 되면 구현 변경과 테스트가 어렵다는 문제가 발생한다.

- DIP는 이 문제를 해결하기 위해 저수준 모듈이 고수준 모듈에 의존하도록 바꾼다.
- 저수준 모듈이 고수준 모듈에 의존하도록 하려면, **추상화된 인터페이스**를 사용하는 것으로 해결할 수 있다.

- 저수준 모듈을 인터페이스화해서 이를 상속받아 구현한다.
- 고수준 모듈은 이 인터페이스에만 의존한다. 이 인터페이스는 고수준 모듈에 속한다.
```java
/// 사용할 저수준 객체, 앞은 인터페이스, 뒤는 상속받아 구현한 객체
RuleDiscounter ruleDiscounter = new DroolsRuleDiscounter();

// 생성자 방식으로 주입
CalculateDiscounterService disService = new CalculateDiscounterService(ruleDiscounter);
```
- 구현 기술을 변경하더라도 Service를 변경하는 것이 아니라, 저수준 구현 객체를 생성하는 코드만 변경하면 된다.(즉, 인터페이스를 상속받는 또 다른 저수준 모듈을 생성)

#### 2.3.1 DIP 주의 사항
<img src="https://nesoy.github.io/assets/posts/20180812/4.png" width=400px>
- 그림의 박스처럼 도메인에 인터페이스, Service가 위치하고, 인프라에 인터페이스를 구현한 저수준 모듈이 위치해야 한다.
- DIP는 단순히 인터페이스와 구현 클래스를 분리하는 것이 아니다.
- 저수준 모듈에서 인터페이스를 도출하는 것이 아니라, 고수준 모듈 관점에서 인터페이스를 도출해야 한다.

#### 2.3.2 DIP와 아키텍처
<img src="https://heeveloper.github.io/img/DDDStart/2-dip-architecture.png" width=400px>

- 인프라스트럭처 영역이 응용 영역과 도메인 영역에 의존(상속)하는 구조가 된다.
- DIP를 적용하면 응용 영역과 도메인 영역에 영향을 최소화하면서 구현체를 변경하거나 추가할 수 있다.
> DIP를 항상 적용할 필요는 없다. 포함하는 게 효과적일 때도 있다. 무작정 적용하는 것이 아니라 DIP의 이점을 얻는 수준에서 적용을 검토하자.

### 2.4 도메인 영역의 주요 구성요소
| 요소                                   | 설명   
| ------------------------------------------ | ----------- |
| 엔티티 ENTITIY                           | 고유의 식별자를 갖는 객체로 자신의 라이프 사이클을 갖는다. 주문, 회원, 상품과 같이 도메인의 고유한 개념을 표현한디. 도메인 모델의 데이터를 포함하며 해당 데이터와 관련된 기능을 제공한다. |
| 밸류 VALUE                          | 고유의 식별자를 갖지 않는 객체로 주로 개념적으로 하나인 값을 표현할 때 사용된다. 배송지 주소를 표현하기 위한 주소나 구매 금액을 위한 금액과 같은 타입이 밸류 타입이다. 엔티티의 속성으로 사용할 뿐만 아니라 다른 밸류 타입의 속성으로도 사용할 수 있다. |
| 애그리거트 AGGREGATE                          | 애그리거트는 연관된 엔티티와 밸류 객체를 개념적으로 하나로 묶은 것이다. 예를 들어 주문과 관련된 Order 엔티티, OrderLine 밸류, Orderer 밸류 객체를 '주문' 애그리거트로 묶을 수 있다. |
| 리포지터리 REPOSITORY                         | 도메인 모델의 영속성을 처리한다. 예를 들어 RDBMS 테이블에서 엔티티 객체를 로딩하거나 저장하는 기능을 제공한다. |
| 도메인 서비스 DOMAIN SERVICE                        | 특정 엔티티에 속하지 않는 도메인 로직을 제공한다. '할인 금액 계산'은 상품, 쿠폰, 회원 등급, 구매 금액 등 다양한 조건을 이용해서 구현하게 되는데, 이렇게 도메인 로직이 여러 엔티티와 밸류를 필요하면 도메인 서비스에서 로직을 구현한다. |

#### 2.4.1 엔티티와 밸류
- DB 테이블의 엔티티와 도메인 모델의 엔티티의 차이 
    - 도메인 모델의 엔티티는 데이터와 함께 도메인 기능을 함께 제공한다.
    - 도메인 모델의 엔티티는 단순히 데이터를 담고 있는 데이터 구조라기보다는 데이터와 함께 기능을 제공하는 객체이다.
    - 또 다른 차이점은 도메인 모델의 엔티티는 두 개 이상의 데이터가 개념적으로 하나인 경우 밸류 타입을 이용해서 표현할 수 있다는 것이다.
- 밸류는 불변으로 구현할 것을 권장, 즉 엔티티의 밸류 타입 데이터를 변경할 때는 객체 자체를 완전히 교체한다는 것을 의미한다.
```java
public class Order{
    private ShippingInfo shippingInfo;
    ...
    private void setShippingInfo(ShippingInfo newShippingInfo){
        if(newShippingInfo == null) throw new IllegalArgumentException();

        this.shippingInfo = newShippingInfo
    }
}
```

#### 2.4.2 애그리거트
- 도메인이 커질 수도 엔티티와 밸류 개수가 증가하고 모델이 복잡해진다.
- 도메인 모델은 개별 객체뿐만 아니라 상위 수준에서 모델을 볼 수 있어야 전체 모델의 관계와 개별 모델을 이해하는 데 도움이 된다.
- 도메인 모델에서 전체 구조를 이해하는데 도움이 되는 것이 바로 **애그리거트**다.
- 애그리거트는 관련 객체를 하나로 묶은 군집이다. ex) 주문이라는 도메인 개념의 하위 모델 주문, 배송지 정보, 주문자, 주문 목록들을 하나로 묶어 주문이라는 상위 개념으로 표현.
- 애그리거트는 군집에 속한 객체를 관리하는 루트 엔티티를 갖는다. 루트 엔티티는 애그리거트에 속해 있는 엔티티와 밸류 객체를 이용해서 애그리거트가 구현해야 할 기능을 제공한다.

#### 2.4.3 리포지터리
- 도메인 객체를 지속적으로 사용하려면 RDBMS, NoSQL과 같은 물리적인 저장소에 도메인 객체를 보관해야 한다.
- 이를 위한 도메인 모델이 리포지터리이다.
- 엔티티나 밸류가 요구사항에서 도출되는 도메인 모델이라면 리포지터리는 구현을 위한 도메인 모델이다.
- 리포지터리는 애그리거트 단위로 도메인 객체를 저장하고 조회하는 기능을 정의한다.
<img src="https://velog.velcdn.com/images%2Fgentledot%2Fpost%2Fd5e90274-4f0f-4ffe-8335-17563763e5f6%2Fimage.png" width=400px>

- 응용 서비스는 의존 주입과 같은 방식을 사용해서 실제 리포지터리 구현 객체에 접근한다.
    - 응용 서비스는 필요한 도메인 객체를 구하거나 저장할 때 리포지터리를 사용한다.
    - 응용 서비스는 트랜잭션을 관리하는데, 트랜잭션 처리를 리포지터리 구현 기술의 영향을 받는다.

### 2.5 요청 처리 흐름
<img src="https://user-images.githubusercontent.com/43809168/97808100-1d80dd00-1ca8-11eb-8d8b-8c530d0a8fb4.png" width=400px>

- 사용자가 애플리케이션에 기능 실행을 요청하면 그 요청을 처음 받는 영역은 표현 영역(컨트롤러)이다. 
- 응용 서비스는 도메인 모델을 이용해서 기능을 구현한다.

### 2.6 인프라스트럭처 개요
- 인프라스트럭처는 표현 영역, 응용 영역, 도메인 영역을 지원한다.
- DIP를 사용하여 인터페이스를 인프라스트럭처 영역에서 구현하는 것이 시스템을 더 유연하고 테스트하기 쉽게 만들어준다.
- 하지만 무조건 인프라스트럭처에 대한 의존을 없앨 필요는 없다.
- 구현의 편리함은 DIP가 주는 장점만큼 중요하기 때문에 DIP의 장점을 해치지 않는 범위에서 응용 영역과 도메인 영역에서 구현 기술에 대한 의존을 가져가는 것이 나쁘지 않다.
- ex) 스프링의 @Transactional, 한 줄로 트랜잭션 처리가 가능해진다.

### 2.7 모듈 구성
<img src="https://velog.velcdn.com/images/hoo5886/post/8fbfb766-f190-4db2-a72a-1b4c370f82fe/image.png" width=400px>

- 도메인이 크면 하위 도메인으로 나누고 각 하위 도메인마다 별도 패키지를 구성한다.
<img src="https://velog.velcdn.com/images/hoo5886/post/f73072ac-5cc5-4465-9f72-24d994651397/image.png" width=400px>

- 모듈 구조를 얼마나 세분화해야 하는지에 대해 정해진 규칙은 없다.