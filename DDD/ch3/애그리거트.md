# ch3. 애그리거트

### 3.1 애그리거트 : 관련된 객체를 하나의 군으로
- 상위 수준에서 모델을 정리하면 도메인 모델의 복잡한 관계를 이해하는 데 도움이 된다.
- 복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들려면 상위 수준에서 모델을 조망할 수 있는 방법이 필요한데, 그 방법이 애그리거트다.
- 수많은 객체를 애그리거트로 묶어서 바라보면 상위 수준에서 도메인 모델 간의 관계를 파악할 수 있다.
<img src="https://kjgleh.github.io/asset/images/ddd/ddd_start_03_01.PNG" width=400px>

- 즉, 애그리거트는 복잡한 모델을 관리하는 기준을 제공한다.
- 애그리거트는 관련된 모델을 하나로 모았기 때문에 한 애그리거트에 속한 객체는 유사하거나 동일한 라이프 사이클을 갖는다.
- 즉, 애그리거트에 속한 구성요소는 대부분 함께 생성하고 함께 제거한다.
- 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다. 경계가 존재한다.
- 경계를 설정할 때 기본이 되는 것은 도메인 규칙과 요구사항이다.
- 함께 변경되는 빈도가 높은 객체를 한 애그리거트에 속할 가능성이 높다.
- ex) 상품과 리뷰의 관계, 리뷰의 변경이 상품에 영향을 주지 않고 반대도 같다. 따라서 둘은 다른 애그리거트에 속한다. 
- 다수의 애그리거트가 한 개의 엔티티 객체만 갖는 경우가 많으며, 두 개 이상의 엔티티로 구성되는 애그리거트는 드물다.

### 3.2 애그리거트 루트
- 도메인 규칙을 지키려면 애그리거트에 속한 모든 객체가 정상 상태를 가져야 한다.
- 애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요한데, 이 책임을 지는 것이 애그리거트 루트 엔티티이다.(대표 엔티티)
- 애그리거트에 속한 객체는 애그리거트 루트 엔티티에 직접, 간접적으로 속하게 된다.

#### 3.2.1 도메인 규칙과 일관성
- 애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는 것이다. 이를 위해 애그리거트 루트는 애그리거트가 제공해야 할 도메인 기능을 구현한다.
- 애그리거트 루트가 제공하는 메서드는 도메인 규칙에 따라 애그리거트에 속한 객체의 일관성이 깨지지 않도록 구현해야 한다.
- 불필요한 중복을 피하고 애그리거트 루트를 통해서만 도메인 로직을 구현하게 만들려면 도메인 모델에 2가지를 습관적으로 적용해야 한다.
    - 단순히 필드를 변경하는 set 메서드를 공개(public) 범위로 만들지 않는다.
    - 밸류 타입은 불변으로 구현한다.
```java
ShippingInfo si = order.getShippingInfo();
si.setAddress(newAddress); // ShippingInfo가 불변이면, 이 코드를 컴파일 에러!
```
- 즉, 밸류 타입의 내부 상태를 변경하려면 애그리거트 루트를 통해서만 가능하다.

#### 3.2.2 애그리거트 루트의 기능 구현
- 애그리거트 루트는 애그리거트 내부의 다른 객체를 조합해서 기능을 완성한다.
```java
public class Order{
    private Money totalAmounts;
    private List<OrderLine> orderLines;

    ...
    // 애그리거트 루트 메서드
}
```

- 보통 한 애그리거트에 속하는 모델은 한 패키지에 속하기 때문에 패키지나 protected 범위를 사용하면 애그리거트 외부에서 상태 변경 기능을 실행하는 것을 방지할 수 있다.

#### 3.2.3 트랜잭션 범위
- **트랜잭션 범위는 작을수록 좋다.**
- 한 트랙잭션이 한 개 테이블을 수정하는 것과 세 개의 테이블을 수정하는 것과 비교하면 성능에서 차이가 발생한다. 즉 전체적인 성능(처리량)이 감소한다.
- **한 트랜잭션에서는 한 개의 애그리거트만 수정해야 한다.**
- 위의 말은, 애그리거트에서 다른 애그리거트를 변경하지 않는다는 것을 의미한다.
- 애그리거트는 최대한 서로 독립적이어야 한다. 한 애그리거트가 다른 애그리거트의 기능에 의존하기 시작하면 결합도가 높아진다.
- 부득이하게 한 트랜잭션으로 두 개 이상의 애그리거트를 수정해야 한다면 애그리거트에서 다른 애그리거트를 직접 수정하지 말고 응용 서비스에서 두 애그리거트를 수정하도록 구현한다.
- 다음 경우에는 한 트랜잭션에서 두 개 이상의 애그리거트를 변경하는 것을 고려할 수 있다.
    - 팀 표준
    - 기술 제약
    - UI 구현의 편리

### 3.3 리포지터리와 애그리거트
- 애그리거트는 개념상 완전한 한 개의 도메인 모델을 표현하므로 객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재한다.
- 리포지터리는 두 메서드를 기본으로 제공
    - save : 애그리거트 저장
    - findById : ID로 애그리거트를 구함
- 필요에 따라 메서드를 추가할 수 있다.
- 애그리거트는 개념적으로 하나이므로 리포지터리는 애그리거트 전체를 저장소에 영속화해야 한다.
- 애그리거트를 영속화할 저장소로 무엇을 사용하든지 간에 애그리거트의 상태가 변경되면 모든 변경을 원자적으로 저장소에 반영해야 한다.
- RDBMS를 이용해서 리포지터리를 구현하면 트랜잭션을 이용해서 애그리거트의 변경이 저장소에 반영되는 것을 보장할 수 있다.

### 3.4 ID를 이용한 애그리거트 참조
- 애그리거트 간의 참조는 루트의 필드를 통해 쉽게 구현할 수 있다.
<img src="https://velog.velcdn.com/images%2Ffreesky%2Fpost%2F2728bdcb-7516-4da4-a797-35174a3c8e9a%2Fimage.png" width=400px>

- 필드를 이용해서 다른 애그리거트를 직접 참조하는 것은 개발자에게 구현의 편리함을 제공한다.
- JPA는 `@ManyToOne`, `@OneToOne`과 같은 애너테이션을 이용해서 연관된 객체를 로딩하는 기능을 제공하므로, 필드를 이용해 다른 애그리거트를 쉽게 참조할 수 있다.
- 하지만 필드를 이용한 애그리거트 참조는 다음 문제를 야기할 수 있다.
    - 편한 탐색 오용
    - 성능에 대한 고민
    - 확장 어려움
- 따라서 **ID 참조**(간접 참조)를 사용하면 모든 객체가 참조로 연결되지 않고 한 애그리거트에 속한 객체들만 참조로 연결된다.
<img src="https://sangjaeoh.github.io/assets/images/posts/books/1/3_4_ID%EC%B0%B8%EC%A1%B0.png
" width=400px>

- ID 참조는 애그리거트의 경계를 명확히 하고 애그리거트 간 물리적인 연결을 제거하기 때문에 모델의 복잡도를 낮춰준다. 또한 애그리거트 간의 의존을 제거하므로 응집도를 높여주는 효과도 있다.
```java
Member member = memberRepository.findById(order.getOrderer().getMemberId());
```

- 지연 로딩을 하는 것과 동일한 결과(?)
- ID를 이용한 참고 방식을 사용하면 복잡도를 낮추는 것과 함께 한 애그리거트에서 다른 애그리거트를 수정하는 문제를 근원적으로 방지할 수 있다.
- 직접 참조가 아니기 때문에 다른 애그리거트의 상태 변경이 불가하다.
- 이렇게 되면 애그리거트별로 다른 구현 기술을 사용하는 것도 가능하다.
- ex) 리포지터리마다 다른 저장소 사용

#### 3.4.1 ID를 이용한 참조와 조회 성능
- 다른 애그리거트를 ID로 참조하면 조회 속도가 문제 될 수 있다.
- N+1 조회 문제 : 조회 대상이 N개일 때 N개를 읽어오는 한 번의 쿼리와 연관된 데이터를 읽어오는 쿼리를 N번 실행한다.
- ID를 이용한 애그리거트 참조는 지연 로딩과 같은 효과를 만드는 데, 지연 로딩과 관련된 대표적인 문제가 N+1 조회 문제이다.
- **N+1 조회 문제**를 해결하기 위해서는 조인을 사용해야 한다.
- 객체 참조 방식으로 바꾸고 즉시 로딩을 사용하도록 하면 되지만 이는 애그리거트 간 참조를 다시 객체 참조로 돌리는 것이라 옳지 않다.
- ID 참조 방식을 사용하면서 N+1 조회와 같은 문제가 발생하지 않도록 하려면 조회 전용 쿼리를 사용해야 한다. ex) JPA를 사용할 때 JPQL을 사용하여 한 번의 쿼리로 로딩하는 방식
- 조회 성능을 높이기 위해 캐시를 적용하거나 조회 전용 저장소를 따로 구성한다. 코드는 복잡해지만 시스템의 처리량을 높일 수 있다.

### 3.5 애그리거트 간 집합 연관
- 애그리거트 간 1-N, M-N 연관, 이 두 연관은 컬렉션을 이용한 연관이다. 카테고리와 상품 간의 연관이 대표적이다.
- 개념적으로는 애그리거트 간에 1-N 연관이 있더라도 성능 문제 때문에 애그리거트 간의 1-N 연관을 실제 구현에 반영하지 않는다.
- 카테고리에 속한 상품을 구할 필요가 있다면 상품 입장에서 자신이 속한 카테고리를 N-1로 연관 지어 구하면 된다.
```java
public class Product{
    ...
    private CategoryId categoryId;
    ...
}
```

- M-N 연관은 개념적으로 양쪽 애그리거트에 컬렉션으로 연관을 만든다.
- 카테고리와 상품 M-N이라고 할 때, 개념적으로는 양방향 연관이 존재하지만 실제 구현에서는 상품에서 카테고리로의 단반향 M-N 연관만 적용하면 된다.
```java
public class Product{
    ...
    private Set<CategoryId> categoryId;
    ...
}
```
- RDBMS를 이용해서 M-N 연관을 구현하려면 조인 테이블을 사용해야 한다.
<img src="https://user-images.githubusercontent.com/22395934/67789177-dec5af00-fab6-11e9-9518-064a3e357467.pngg
" width=400px>

- JPA를 이용하면 다음과 같은 매핑 설정을 사용해서 ID 참조를 이용한 M-N 단방향 연관을 구현할 수 있다.
```java
@Entity
@Table(name = "product")
public class Product{
    @EmbeddedId
    private ProductId id;

    @ElementCollection
    @CollectionTable(name = "product_category",
        joinColumns = @JoinColume(name = "product_id"))
    private Set<CategoryId> categoryIds;
}
```
- 이 매핑은 카테고리 ID 목록을 보관하기 위해 밸류 타입에 대한 컬렉션 매핑을 이용했다.

### 3.6 애그리거트를 팩토리로 사용하기 -> 다시 보기
- Product 생성 가능 여부를 확인하는 로직을 Store로 옮김으로서 이 로직을 변경해도 도메인 영역의 Store만 변경하면 되고 응용 서비스는 영향을 받지 않는다. 도메인 응집도도 높아졌다. 이것이 바로 애그리거트를 팩토리로 사용할 때 얻을 수 있는 장점이다.
- 애그리거트가 갖고 있는 데이터를 이용해서 다른 애그리거트를 생성해야 한다면 애그리거트에 팩토리 메서드를 구현하는 것을 고려해 보자.

