# 팩토리 패턴 : 객체지향 빵 굽기
- 객체의 인스턴스를 만드는 과정이 항상 공개되어야 하는 것은 아니다.
- 오히려 모든 것을 공개했다가는 결합 문제가 생길 수 있다.
- 팩토리 패턴으로 불필요한 의존성을 없애서 결합 문제를 해결해보자.

- 이전에 특정 구현을 바탕으로 프로그래밍하지 않아야 한다는 원칙을 배웠다. 그러나 `new` 를 사용하게 되면 구상 클래스의 인스턴스가 만들어지므로 결국 특정 구현을 사용하게 되는 셈이다.
- `new` 는 자바의 뼈대를 이루는 연산자이므로 아예 사용하지 않을 수는 없다. 이 때 인터페이스에 맞춰서 코딩하면 시스템에서 일어날 수 있는 여러 변화에 대응할 수 있다. 인터페이스를 바탕으로 만들어진 코드는 어떤 클래스든 특정 인터페이스만 구현하면 사용할 수 있기 때문이다. 이는 모두 **다형성** 덕분이다.
- 반대로 구상 클래스를 많이 사용하면 새로운 구상 클래스가 추가될 때마다 코드를 고쳐야 하므로 변경에 닫혀 있는 코드가 되는 셈이다. 새로운 구상 형식을 써서 확장해야 할 때는 어떻게 해서든 다시 열 수 있게 만들어야 한다.
- 어떻게 해야 구상 클래스의 인스턴스 생성 부분을 전부 찾아 나머지 부분으로부터 분리(캡슐화)할 수 있을까?

### 기존 코드
```java
Pizza orderPizza(String type) {
	Pizza pizza;
    
    if (type.equals("cheese")) {
    	pizza = new CheesePizza();
    } else if (type.equals("potato") {
    	pizza = new PotatoPizza();
    } else if (type.equals("pepperoni") {
    	pizza = new PepperoniPizza();
    }
    
    pizza.prepare();
    pizza.bake();
    pizza.cut();
    pizza.box();
    return pizza;
}
```
- 변하는 부분 : 피자 종류를 선택하고 그 인스턴스를 생성하는 부분, 즉 문제가 되는 부분
- 변하지 않는 부분 : 피자를 굽고, 커팅하고 포장하는 과정
- 인스턴스를 만드는 구상 클래스를 선택하는 부분을 캡슐화하자.

### 객체 생성 부분 캡슐화하기
- 객체 생성을 처리하는 클래스를 **팩토리(Factory)**라고 부른다. 

### 객체 생성 팩토리 만들기
```java
public class SimplePizzaFactory {
	
    public Pizza createPizza(String type) }
    	Pizza pizza = null;
        
        if (type.equals("cheese")) {
    		pizza = new CheesePizza();
    	} else if (type.equals("potato") {
    		pizza = new PotatoPizza();
    	} else if (type.equals("pepperoni") {
    		pizza = new PepperoniPizza();
    	}
        
        return pizza;
    }
    
}
```
- 간단한 팩토리를 정적 메소드로 정의하는 기법도 많이 쓰인다. 정적 팩토리(static factory)라고 부르기도 한다.
- 정적 메소드를 쓰면 객체 생성 메소드를 실행하려고 객체의 인스턴스를 만들지 않아도 되기 때문에 사용한다.
- 하지만 서브클래스를 만들어서 객체 생성 메소드의 행동을 변경할 수 없다는 단점이 있다.

### 클라이언트 코드 수정하기 
```java
public class PizzaStore {
	SimplePizzaFactory factory;
    
    public PizzaStore(SimplePizzaFacotory factory) {
    	this.factory = factory;
    }
    
    pubic Pizza orderPizza(String type) {
    	Pizza pizza;
        
        pizza = factory.createPizza(type);
        
        pizza.prepare();
        pizza.bake();
        pizza.cut();
        pizza.box();
        
        return pizza;
    }
    
    // 기타 메소드
    
}
```

### '간단한 팩토리의 정의
- **간단한 팩토리(Simple Factory)**는 디자인 패턴이라기 보다는 프로그래밍에서 자주 쓰이는 관용구에 가깝다.
<img src="https://velog.velcdn.com/images/superkkj/post/6fca15b3-6f48-48a7-b72a-ea8db71f99a2/image.png" width=500px>

> 주의 : 디자인 패턴을 얘기할 때, "인터페이스를 구현한다"라는 표현이 나온다고 해서 항상 "클래스를 선언하는 부분에 implements 키워드를 써서 어떤 자바 인터페이스를 구현하는 클래스를 만든다"라고 생각하면 안된다. 일반적으로 어떤 상위 형식(클래스와 인터페이스)에 있는 구상 클래스는 그 상위 형식의 "인터페이스를 구현하는" 클래스라고 생각하면 된다.

